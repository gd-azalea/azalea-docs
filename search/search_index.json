{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"framework-guide/best-practices/","title":"Best practices","text":"<p>Keep direct changes as close as possible to their component. Keep reusable logic parts in a globally accessible class. For example: The WorldTime with GUI. The changes for the GUI, updating the labels and such - keep that in the actual GUI/WorldTimeMarginContainer (the wrapper for the labels). That way, in order to see how they get updated, you only have to find the GUI element itself. However the main code is in a global WorldTime class, which has its own test</p> <p>Areas should inherit from abstract/BaseArea. NPCs should inherit from abstract/NPC.</p>"},{"location":"framework-guide/best-practices/#how-to","title":"How to:","text":""},{"location":"framework-guide/best-practices/#how-to-set-up-signals","title":"How to set up signals","text":"<p>From the place you\u2019re sending from:</p> <pre><code>signal day_end\n...\nday_end.emit()\nday_end.emit(\"hit\", \"Dark lord\", 5)\n</code></pre> <p>From the place you\u2019re listening to:</p> <pre><code>GlobalSignals.day_end.connect(my_method)\n\nfunc my_method() -&gt; void:\n    pass\n</code></pre>"},{"location":"framework-guide/best-practices/#how-to-spawn-new-entities","title":"How to spawn new entities:","text":"<pre><code>SpawnUtils.spawn(packedSceneToSpawn, level_node, position)\nOR\nvar plant = plantScene.instantiate()\nvar level_node = GlobalState.find_level_node()\nlevel_node.add_child(plant)\n\nplant.name = \"planted_\" + str(loc)\nplant.set_owner(level_node)\nplant.add_to_group(\"persist\")\n\nplant.position = loc\n</code></pre>"},{"location":"framework-guide/best-practices/#how-to-destroy-object","title":"How to destroy object:","text":"<pre><code>level_node.queue_free()\n</code></pre>"},{"location":"framework-guide/best-practices/#load-a-resource-like-audio","title":"Load a resource, like audio?","text":"<pre><code>load(\"res://path/to/audio/file\")\n</code></pre>"},{"location":"framework-guide/best-practices/#how-to-add-a-ttl","title":"How to add a ttl:","text":"<pre><code>var ttl = 10 #in secs\nvar init: int = 0\n\nfunc _ready() -&gt; void:\n    init = Time.get_ticks_msec()\n\nfunc _physics_process(delta: float) -&gt; void:\n    if (Time.get_ticks_msec() - init) &gt; (ttl*1000):\n        queue_free()\n</code></pre>"},{"location":"framework-guide/best-practices/#how-to-get-locale","title":"How to get locale:","text":"<pre><code>OS.get_locale_language()\n\nreturns a value like 'fr'\n    cmn = mandarin chinese\n    ko = korean\n    nl = dutch\n    'else' = english\nCan use this to default to a locale\nsee also https://www.youtube.com/watch?v=Lw-3Tnwv4Ds&amp;ab_channel=jitspoe\n\nTranslationServer.set_locale()\n</code></pre>"},{"location":"framework-guide/best-practices/#create-a-timer-via-code","title":"Create a timer via code","text":"<pre><code>var timer := Timer.new()\ntimer.wait_time = 1.0 # 1 second\ntimer.one_shot = false\ntimer.autostart = true\ntimer.connect(\"timeout\", WorldTime.on_global_timer_timeout)\nadd_child(timer)\n</code></pre>"},{"location":"framework-guide/best-practices/#on-button-press","title":"On button press:","text":"<pre><code>    if Input.is_action_just_pressed(\"undo\"):\n        undo()\n</code></pre>"},{"location":"framework-guide/best-practices/#logging","title":"Logging:","text":"<pre><code>static var logger: Log = Log.new(\"StorageRepository\")\nlogger.debug(\"add_to_player_inventory: \")\n</code></pre>"},{"location":"framework-guide/best-practices/#export-with-options","title":"Export with options:","text":"<pre><code>enum Direction {LEFT, RIGHT, UP, DOWN}\n\n@export var dir: Direction\n</code></pre>"},{"location":"framework-guide/classes/","title":"Classes","text":"<p>Global functions:</p> <ul> <li>Lookups + cache<ul> <li>Find the current \u201clevel\u201d, see https://github.com/kevindeyne/azalea-prototype/blob/main/generic/global_state.gd#L16</li> <li>Find the \u201cplayer\u201d</li> <li>Find the \u201cplayer_spawn\u201d Marker2D within a _level</li> <li>Find the \u201cplacer\u201d</li> <li>Find the audio players</li> </ul> </li> <li>Controller checks<ul> <li>Incl axis check w/ deadzone Input.is_action_just_released</li> </ul> </li> <li>Logging (static)<ul> <li>Log with debug levels (should be easily turned off when going live)<ul> <li>Ideally you can turn on/off \u2018groups\u2019 of logging</li> </ul> </li> </ul> </li> <li>JSONUtils (static)<ul> <li>String to Vector2 array</li> </ul> </li> <li>DialogueFunctions<ul> <li>Easy way to trigger methods from dialogue</li> </ul> </li> </ul> <p>GlobalSignals:</p> <p>Easy place for all signals to connect to</p> <p>Level Manager:</p> <ul> <li>Levels must understand if they\u2019re exterior or interior</li> </ul> <p>Weather:</p> <p>x</p> <p>Day/Night cycle:</p> <p>x</p> <p>Area transition (composition):</p> <p>Add a collider to it</p> <p>Can add an audio queue to play</p> <p>Note if current area should stay in memory, keep_current_area_in_memory</p> <p>Talkable (composition):</p> <p>Ability to start a conversation (which dialogue?)</p> <p>Shows the \u2018available to talk\u2019 hover icon</p>"},{"location":"framework-guide/folder-structure/","title":"Folder structure","text":"<p>Several pieces of framework code depend on the folder structure being consistent. We expect it to be structured as follows:</p> <ul> <li>Scenes<ul> <li>Framework</li> <li>Levels         - Abstract folder (base class to inherit from)<ul> <li>Woods</li> <li>House1</li> <li>...</li> </ul> </li> <li>Characters (this contains the NPCs)<ul> <li>Abstract folder (base class to inherit from)</li> </ul> </li> <li>GUI (in game overlays)</li> <li>Menus (full screen menus)</li> </ul> </li> <li>Scripts<ul> <li>Framework</li> <li>GUI</li> <li>Levels<ul> <li>Woods</li> <li>House1</li> <li>...</li> </ul> </li> </ul> </li> <li>Assets<ul> <li>Audio</li> <li>Images<ul> <li>Characters</li> <li>Areas</li> <li>...</li> </ul> </li> <li>...</li> </ul> </li> <li>Shaders</li> <li>Dialogue (dialogue scripts)</li> <li>Translations<ul> <li>Dialogue</li> <li>main_menu</li> <li>...</li> </ul> </li> </ul> <p>Any generic script or scene should be added under /Framework/. Anything specific to the level should be added under /Levels/.</p> <p>The level scenes are also important for level loading. A level should inherit from the abstract level node.</p> <p>Since NPCs can be spawned anywhere, they all need to be in Scenes/Characters. They need to inherit from the abstract NPC node.</p>"},{"location":"framework-guide/gui-layers/","title":"GUI layers","text":"<p>To ensure that the right elements come out on top, every GUI element needs to be part of a CanvasLayer, with a certain layer level. The higher the number, the more visible it is (ie 120 covers up 110, 100, 90, etc; wheras 20 only covers up 10, 5, etc). To keep margin for expansion, never pick the extremes (121-128 or 0-10). Between layers, try to have 10 layers available as well, to allow new layers to 'slide in' as needed.</p> <p>Here is an overview of the layers used:</p> <ul> <li>Loading blackout - res://scenes/menus/Loading.tscn - 120</li> <li>Menus - 100</li> <li>Dialogue - 65</li> <li>GUI (Time, Date) - res://scenes/gui/GUI.tscn - 50</li> </ul>"},{"location":"framework-guide/gui-layers/#z-index","title":"Z-index","text":"<p>Y sorting should usually handle this, but players and npcs are not in the same structure as the level, due to being able to load those around. As such we have some custom code to do exactly the same by dynamic z-index changing. Higher z-index means drawing in front of others.</p> <ul> <li>Landscape/background: 0</li> <li>Behind default: 3</li> <li>Default z-index: 10</li> <li>In front of default : 17</li> </ul> <p>Set this on the parent node of the sprite. IE on player, not on the animatedSprite2d of player.</p>"},{"location":"framework-guide/level-loading/","title":"Level loading","text":"<p>Gameplay is consistently run from Root.tscn. This default scene initializes essential components such as the GUI, Player, Weather, and Day/Night Cycle. Importantly, it contains a <code>\ud83c\udf0f Level</code> node, where the active level is loaded as a child node.</p> <p>This setup allows for persistent audio and GUI elements across different scenes, minimizing noticeable transitions and hard cuts during level loading.</p> <p>All levels should be stored in <code>res://scenes/levels/</code> for quick and easy name-based lookups.</p>"},{"location":"framework-guide/level-loading/#scene-loading-process","title":"Scene Loading Process","text":"<p>Loading a new scene involves the following steps:</p> <ul> <li>Fading to black.</li> <li>Loading the scene file.</li> <li>Adding the new scene as a child node.</li> <li>Removing the previous scene node.</li> <li>Spawning the player in the correct position.</li> </ul> <p>The primary class responsible for this process is SceneLoader. You can load a level with the following call:</p> <pre><code>SceneLoader.load(get_tree(), \"MyLevelName\")\n</code></pre> <p>Additionally, you have the option to keep the previous level in memory by using a flag. This is useful for scenarios like transitioning between the interior and exterior of a building. By  retaining the larger exterior scene in memory, returning outside becomes nearly instantaneous since it was never fully unloaded.</p> <pre><code>SceneLoader.load_w_memory_flag(get_tree(), \"MyLevelName\", true)\n</code></pre>"},{"location":"framework-guide/level-loading/#example","title":"Example","text":"<p>You would only need to do this one way. Let's say you have a city and a building. The city is a big map to load, the building a small one. You would load into the city originally like this:</p> <pre><code>SceneLoader.load(get_tree(), \"City\")\n</code></pre> <p>Then the area transition to the building could be like this:</p> <pre><code>SceneLoader.load_w_memory_flag(get_tree(), \"Building\", true)\n</code></pre> <p>The quick building scene gets loaded, but the city remains in memory. This allows you to hop into the building, do a quick action, then switch back to the city really quickly like this:</p> <pre><code>SceneLoader.load(get_tree(), \"City\")\n</code></pre> <p>Calling the above would remove the building from memory. Since the city never got unloaded, there is practically no loading. The downside to this is that more memory is used, so it is not advised to do this with two back to back heavy levels.</p>"},{"location":"framework-guide/level-loading/#code-references","title":"Code references","text":"<p>SceneLoader.gd - new impl</p> <p>scene_transition.gd - prototype</p>"},{"location":"framework-guide/multiplayer/","title":"Multiplayer","text":"<p>Our multiplayer is peer-to-peer. But p2p has some common issues, like discovery and network setup required. We use Steam to alleviate these.</p> <p>We mostly use GodotSteam (https://godotsteam.com/)</p> <p>See prototype: https://github.com/gd-azalea/multiplayer-prototype</p> <p>As a user you can choose to 'host' a lobby. Once you do so, you can show up in the lobby list of other players (friends only). They can select your name and ask to join.</p> <p>When asking to join a handshake p2p message is sent. With the handshake comes the request to the host to accept a user joining (?). If they choose to agree, a p2p message will be send back telling you of the succesful join.</p> <p>With the join success message a player gets spawned. As the player does actions, these get synchronized across clients.</p> <p>Since the plugins for this (Steam Multiplayer Peer and GodotSteamSync) have various issues with them, we use our own implementation.</p> <p>Upon load, a full sync is done via reliable p2p. Once playing, we send data to a bus which collects all changes until the tick time comes, which is when an unreliable p2p is sent out.</p> <p>Sync expectation: - Player position, orientation, action (explicitly not hash protected) - Placeable - Destructable - Quest_progress - Known_recipes - Storage - Weather, time, season determination (host, hash protected)</p> <p>Unique to player (does not get synced): - Controls - Settings</p> <p>Everything aside from player position/orientation/action is hash protected. Since this is synced through unreliable communication, we cannot be sure if we 'miss' a placeable or destructable, for example. Instead of sending the data of all placeables/destructables in a scene each time, we instead send a hash of all items. As long as the hash is the same, we know we're in sync. If the hash is different, we need a reliable call made to ensure we're back in sync.</p> <p>Two players can be in different scenes/areas. If the player is in the same area and 'close enough', they will follow along with cutscenes. This means we need info on where to 'start' a conversation, lock the conversation choices/speed to the owner of the conversation (whomever starts it) and sync it.</p> <p>After the handshake, the player gets a welcome package. This contains where the other players are at that time, so the new player can spawn into that map. It also contains the details for the game (ie placeables, destructables, weather, time, etc). From the spawn point on, only sync data will be passed along.</p> <p>Each item has a MultiplayerSync node attached to it. This runs through _process and takes any configured properties and sends them along to the MultiplayerBus. The MultiplayerBus collects all events from everyone, and bundles them together in batches. It also does translations (ie 'Player' from host perspective is a lobby member from another perspective). It has an internal timer, and once the timer hits (usually 30/s) it sends an unreliable p2p bundle message across the relay known as \"sync\".</p> <p>SteamNetwork will receive messages and send the incoming messages to MultiplayerUtils for translating to world updates.</p>"},{"location":"framework-guide/npc-schedules/","title":"Npc schedules","text":""},{"location":"framework-guide/npc-schedules/#npc-scheduling-system-overview","title":"NPC Scheduling System Overview","text":"<p>NPC schedules are stored in the <code>npc_schedule</code> table within <code>data.db</code>, while in the game world, only <code>Marker2D</code> nodes are placed at various locations, representing points that NPCs can navigate to.</p> <p>NPCs are controlled by a central script that simulates their movement. Rather than continuously moving behind the scenes, the system simulates NPC presence and movement based on game events and time:</p> <ul> <li>When an area is loaded, the system determines where each NPC in that area should be at the current in-game time and spawns them at the appropriate <code>Marker2D</code> locations.</li> <li>As time progresses within any given area, the system checks NPC schedules and triggers movement when needed. If an NPC is already in the area and their schedule dictates they should move, the NPC will receive a command to navigate to a specific marker. If they are not yet present in the area, they will be spawned directly at the marker.</li> </ul> <p>NPCs inherit from a base abstract class called <code>NPC</code>, which provides shared functionality, including the <code>moveTo(markerId: String)</code> method. This method uses <code>NavigationRegion2D</code> to move the NPC towards a marker, identified by the provided <code>markerId</code>. The method is also utilized by the <code>NPCScheduleManager</code> to handle NPC movement based on schedule updates.</p> <p>Schedules can include wildcard characters (e.g., <code>*</code>) to allow flexibility, and may also reference certain conditions (to be defined in the future). At the start of each scene, NPC schedules are initialized via the <code>SceneLoader</code>, specifically within the <code>complete_load_with_npc_spawn</code> function.</p> <p>The <code>NPCScheduleManager</code> operates at the root level, syncing with changes in <code>WorldTime</code>. Whenever time updates, it checks whether NPCs need to spawn, move, or despawn based on the current schedule in the loaded map.</p> <p>Additionally, there is a test to validate that schedules are coherent and don\u2019t terminate abruptly, ensuring consistent NPC behavior throughout the game.</p>"},{"location":"framework-guide/npc-schedules/#todo","title":"TODO","text":"<p>If the area is loaded in between two schedules, a best guess to the location is made. IE if time has passed 20% between two schedules, the user would be somewhere 20% between the two markers. We should have a unity prototype code for this.</p> <p>See I:\\Unity\\FarmGame\\FarmGame\\Assets\\Scripts\\NPC</p> <p>Looks like in Unity we did this with a NavMeshAgent. It would be appropriate to use something like https://docs.godotengine.org/en/stable/tutorials/navigation/navigation_introduction_2d.html here too. The Unity code does not spawn NPCs, we should still have a global script do so per timeframe (perhaps this can link to WorldTime.(signal)update_time).</p>"},{"location":"framework-guide/save-system/","title":"Save system","text":"<p>Handled in https://github.com/gd-azalea/azalea/blob/main/prototype/save_games.gd</p> <p>There is a base file of the database for the game in the game's resources, available from res://data.db. This contains things like item lists, etc. When starting the game (see code), the resource is copied over into the user's persistent app data. This is the database that will be loaded as current.db.</p> <p>As the game progresses, the current.db gets updated. This means that if you stop the game and continue, this same persistent file can just be reloaded and the game continued.</p> <p>When you make a save game, you're calling the backup function of the current.db into a new file (https://github.com/2shady4u/godot-sqlite?tab=readme-ov-file#functions). This allows you to copy the database file while it is in use (because open database files are locked).</p> <p>When loading a game it's doing a restore of the file into current.db, overwriting the current.db file.</p> <p>Since there is a current.db that would always be made, it would make for annoying testing. A forced reset each startup is triggered via AbstractRepository (DirAccess.open(AbstractRepository.DB_PATH).remove(\"current.db\") #this resets the game each time)</p>"},{"location":"framework-guide/settings/","title":"Settings","text":"<p>Please see https://github.com/godotengine/godot-demo-projects/blob/master/gui/multiple_resolutions/main.gd for a thorough resolution scaling implementation</p> <p>Storage is done in SettingsRepository. There are convenience functions in GraphicsLookup and LocaleLookup for storing and retrieving this. Settings are made in the OptionsMenu, you can get there from StartMenu (it is part of StartMenu)</p> <p>The _ready() of OptionsMenu loads in the existing values in the settings. When you make a change in OptionsMenu, you'll be making the changes likely through a MultiSelect which has no idea of specific implementation. It instead fires off a signal to an OptionsLogic instance within OptionsMenu. This class contains all logic on how to approach different settings.</p> <p>If no values exist, a default setting is applied. This is defined in SettingsRepository's default_settings() function.</p> <p>In case you are in the editor, the default settings will be the project settings display/window/size/viewport_width/height in Windowed mode. Outside of the editor, it will default to Fullscreen mode with your screen's resolution set.</p> <p>Things of note: - Fullscreen is WINDOW_MODE_EXCLUSIVE_FULLSCREEN whereas borderless is WINDOW_MODE_FULLSCREEN (on windows) - You set resolution through get_viewport().content_scale_size = Vector2(w,h)</p>"},{"location":"framework-guide/translations/","title":"Translations","text":"<p>There is a settings file in the DB that can track options selected by the player. If this has not been set, things like locale are auto-detected by OS.get_locale().</p> <p>If the locale is found in the translations, it will load this by default. If a non-matching locale is found, it will default to US_en.</p> <p>Translations for items, quests, etc are added in the current.db itself.</p> <p>Translations for menus and GUI elements are added in the res://translations/ folder in CSV format, for example: res://translations/main_menu.csv</p> <p>You can request the current appropriate language in code via LocaleLookup.findLanguage(). This both returns an ISO code as well as sets it in the TranslationServer of Godot.</p> <p>Meaning you can manually pass it around or lookup GUI/menu keys such as $\"Buttons/Load game\".text = tr(\"MAIN_LOAD_GAME\")</p> <p>To test languages, you can set the 'test_locale' in LocaleLookup.</p>"},{"location":"framework-guide/usecases/","title":"Usecases","text":"<p>The framework is very data centric. This page illustrates usecases and how the code approaches this.</p>"},{"location":"framework-guide/usecases/#cutting-down-a-tree-obj_tree_1","title":"Cutting down a tree (obj_tree_1)","text":"<ul> <li>Get tree object coordinates</li> <li>Remove the tree object from the scene</li> <li>Add an entry to <code>destructable</code>:<ul> <li>object_name = obj_tree_1</li> <li>map = current map</li> <li>save_id = current runtime savestate</li> </ul> </li> <li>Spawn in place some resources (wood)</li> <li>Add entry to <code>placeable</code>:<ul> <li>save_id = current runtime savestate</li> <li>item_id = wood</li> <li>map = current map</li> <li>coordinates = obj_tree_1 location</li> <li>amount = 3 (or similar)</li> </ul> </li> <li>Trigger a signal placeable_added<ul> <li>The scene then needs to listen to this signal and spawn items</li> <li>Instead of each scene implementing this, there is a global PlaceableListener that can interact with any active scene</li> </ul> </li> </ul>"},{"location":"framework-guide/usecases/#picking-up-an-item-from-the-ground","title":"Picking up an item from the ground","text":"<ul> <li>Get object coordinates, item_id and amount</li> <li>Add to inventory</li> <li>Add item_id + amount to <code>storage</code> where save_id = 'temp_save' and inventory = true</li> <li>Though if this item already exists, stack the amounts. So first do a WHERE item_id = ... and if match, append amount</li> <li>Remove from <code>placeable</code></li> <li>DELETE FROM PLACEABLE WHERE MAP = 'current_map' AND save_id = 'temp_save' AND coordinates = 'object_coordinates'</li> <li>Remove the object from scene</li> </ul>"},{"location":"framework-guide/usecases/#placing-a-seed-in-the-ground","title":"Placing a seed in the ground","text":"<ul> <li>Remove from inventory</li> <li>Reduce amount from <code>storage</code> where save_id = 'temp_save' and inventory = true for item_id</li> <li>If amount = 0, remove the entry entirely</li> <li>Add to <code>placeable</code></li> <li>Add object to scene via instantiate</li> </ul>"},{"location":"framework-guide/usecases/#determining-an-npc-location","title":"Determining an NPC location","text":"<p>As time moves, NPCs can switch locations. NPC schedules are stored in 'npc_schedule'.  Every 'time tick', this table is queried to see if changes occur. It looks at start_time only.  If a start_time is matching, then we look at the NPC and the map.  If the NPC is currently in the map scene and they are moving within the map, they start moving to the marker_id.  If a condition is present, we run the condition logic first. If they have an animation, we run the animation.   An NPC cannot move outside of a map without passing a transition marker_id. If they hit a transition marker, they should disappear from the scene.  The map might show the current location of all NPCs. We can show details for those in our loaded map, the others we can show which map they are in.</p>"},{"location":"framework-guide/usecases/#loading-an-area","title":"Loading an area","text":"<p>Loading an area always happens in the background and through a swap. Read more about this in level-loading. Once a scene is loaded, but before it is shown, we correct the scene to match the data. This includes going over <code>placeable</code> and <code>destructable</code> items (in that order) where map = 'new_scene_location' NPC schedules are also read (see above) and the appropriate characters are loaded.</p>"},{"location":"framework-guide/usecases/#making-a-save","title":"Making a save","text":"<p>Similar to level loading, this should freeze the game and turn to a status screen. A new entry should be made in <code>save</code>. This gives a new ID. Anything tied to the temp_save_id should get duplicated to both temp_save and the new ID.</p>"},{"location":"mods/","title":"Mods","text":"<p>I want to integrate https://github.com/GodotModding/godot-mod-loader for mod support.</p> <p>However this is currently broken for Godot 4.2, and depends on the following issues to be resolved:</p> <ul> <li>https://github.com/GodotModding/godot-mod-loader/issues/315</li> <li>https://github.com/godotengine/godot/issues/83542</li> <li>https://github.com/GodotModding/godot-mod-loader/issues/345</li> </ul>"},{"location":"references/","title":"References","text":"<p>A global bibliography to other relevant documentation, used frameworks or assets.</p>"},{"location":"references/#documentation","title":"Documentation","text":"<ul> <li>This documentation is written in  Markdown</li> <li>The framework for this documentation is Mkdocs-material</li> <li>The data model is available here</li> </ul>"},{"location":"references/#plugins-used","title":"Plugins used","text":"<ul> <li>GUT - Unit testing</li> <li>Godot-SQLite - Connects to SQLite, which we use to load and persist data</li> <li>Phantom Camera - Flexible camera system</li> <li>GodotSteam - Multiplayer P2P relay</li> </ul>"}]}